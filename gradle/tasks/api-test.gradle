tasks.register('api', Test) {
  description = "Runs api tests against docker-compose stack"
  group = "Verification"

  mustRunAfter tasks.named('test')

  testClassesDirs = sourceSets.apiTest.output.classesDirs
  classpath       = sourceSets.apiTest.runtimeClasspath
  useJUnitPlatform()

  dependsOn tasks.composeUp
  finalizedBy tasks.composeDown

  jvmArgs = ['-Xshare:off']
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat = 'full'
    showStandardStreams = true
  }
}

tasks.named('check') {
  dependsOn tasks.named('api')
}

tasks.named('build') {
  dependsOn tasks.named('test')
  dependsOn tasks.named('api')
}

sourceSets {
  apiTest {
    java {
      compileClasspath += sourceSets.main.output
      runtimeClasspath += sourceSets.main.output

    }
    resources.srcDir file('src/apiTest/resources')
  }
}

configurations {
  apiTestImplementation.extendsFrom testImplementation
  apiTestRuntimeOnly.extendsFrom testRuntimeOnly

  // Ensure testRuntimeClasspath can be resolved for agent injection
  testRuntimeClasspath {
    canBeResolved = true
  }
}

dependencies {
  apiTestImplementation platform(libs.junit.bom)
  apiTestRuntimeOnly libs.junit.jupiter.engine

  apiTestImplementation(libs.spring.boot.starter.test) {
    exclude group: 'junit', module: 'junit'
    exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
  }
  apiTestRuntimeOnly libs.junit.platform.launcher
  apiTestCompileOnly libs.lombok
  apiTestAnnotationProcessor libs.lombok
}

dockerCompose {
  useComposeFiles = ['docker-compose.yml']
  startedServices = ['app', 'db']

  buildBeforeUp = true
  waitForTcpPorts = true
  upAdditionalArgs = ['--wait', '--wait-timeout', '120']

  captureContainersOutput = true
  removeOrphans = true
  stopContainers = true
  removeContainers = true

  useDockerComposeV2 = true
  dockerExecutable = 'docker'
}
